<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <link rel="icon" href="data:,">
        <title>{{name}}</title>
        <style>
            body {
                margin: 0;
                font-family: Arial, Helvetica, sans-serif;
            }
            canvas { width: 100%; height: 100%; }
            input[type=range] { width: 100%; }
            #container { position: relative; }
            #container canvas, #overlay { position: absolute; }
            #overlay { z-index: 1; width: 100%; }
            #overlay div { padding: 5px; }

            #loader {
                border: 5px solid #f3f3f3; /* Light grey */
                border-top: 5px solid #3d3d3d; /* Grey */
                border-radius: 50%;
                width: 40px;
                height: 40px;
                animation: spin 1s linear infinite;
                position: absolute;
                top: 50%;
                left: 50%;
                z-index: 2;
            }

            @keyframes spin {
                0% { transform: rotate(0deg); }
                100% { transform: rotate(360deg); }
            }
        </style>
    </head>
    <body>
        <div id="loader"></div> 
        <div id="container">
            <div id="overlay">
                {{#inputs}}
                <div>
                  <label for="{{id}}">{{name}}</label>
                  {{#number}}
                  <input type="number" id="{{id}}" value="{{value}}">
                  {{/number}}
                  {{#range}}
                  <input type="range" id="{{id}}" min="{{range.min}}" max="{{range.max}}" value="{{range.value}}" step="{{range.step}}">
                  {{/range}}
                  {{#bool}}
                  <input type="checkbox" id="{{id}}" {{#value}}checked{{/value}}>
                  {{/bool}}
                </div>
                {{/inputs}}
            </div>

            <div id="canvas"></div>
        </div>

        <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/rhino3dm@0.13.0/rhino3dm.min.js"></script>
        <script type="module">

import * as THREE from 'https://unpkg.com/three@0.121.1/build/three.module.js';
import { OrbitControls } from 'https://unpkg.com/three@0.121.1/examples/jsm/controls/OrbitControls.js';

let inputs = {}

for (const input of document.getElementsByTagName('input')) {
  switch (input.type) {
    case 'number':
      inputs[input.id] = input.valueAsNumber
      input.onchange = onSliderChange
      break
    case 'range':
      inputs[input.id] = input.valueAsNumber
      input.onmouseup = onSliderChange
      input.ontouchend = onSliderChange
      break
    case 'checkbox':
      inputs[input.id] = input.checked
      input.onclick = onSliderChange
      break
    default:
      break
  }
}

let data = {
  definition: '{{name}}',
  inputs: inputs
}

let _threeMesh, _threeMaterial, rhino

// rhino3dm loads asynchronously, so we need to wait for it...
rhino3dm().then(async m => {
  console.log('Loaded rhino3dm.')
  rhino = m // global

  init()
  compute()
})

/**
 * Call appserver
 */
async function compute() {
  // construct url for GET /solve/definition.gh?name=value(&...)
  const url = new URL('/solve/{{name}}', window.location.origin)
  Object.keys(data.inputs).forEach(key => url.searchParams.append(key, data.inputs[key]))
  console.log(url)

  try {
    const response = await fetch(url)
  
    if(!response.ok)
      throw new Error(response.statusText)

    const responseJson = await response.json()

    // hide spinner
    document.getElementById('loader').style.display = 'none'

    // get mesh
    let item = responseJson.values[0].InnerTree['{ 0; }'][0]
    let mesh
    if (item.type === 'System.String') {
      mesh = rhino.DracoCompression.decompressBase64String(JSON.parse(item.data))
    } else if (item.type === 'Rhino.Geometry.Mesh') {
      mesh = rhino.CommonObject.decode(JSON.parse(item.data))
    }

    mesh.scale(0.1)

    if (!_threeMaterial) {
      _threeMaterial = new THREE.MeshNormalMaterial()
    }

    let threeMesh = meshToThreejs(mesh, _threeMaterial)
    replaceCurrentMesh(threeMesh)

    zoomCameraToSelection(camera, controls, [ threeMesh ])

    mesh.delete()

  } catch(error) {
    console.error(error)
  }
}

/**
 * Called when a slider value changes in the UI. Collect all of the
 * slider values and call compute to solve for a new scene
 */
function onSliderChange () {
  // show spinner
  document.getElementById('loader').style.display = 'block'

  // get slider values
  let inputs = {}

  for (const input of document.getElementsByTagName('input')) {
    switch (input.type) {
    case 'number':
      inputs[input.id] = input.valueAsNumber
      break
    case 'range':
      inputs[input.id] = input.valueAsNumber
      break
    case 'checkbox':
      inputs[input.id] = input.checked
      break
    default:
      break
  }
  }
  
  data.inputs = inputs
  compute()
}

// BOILERPLATE //

var scene, camera, renderer, controls

function init () {
  scene = new THREE.Scene()
  scene.background = new THREE.Color(1,1,1)
  camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 1, 1000 )

  renderer = new THREE.WebGLRenderer({antialias: true})
  renderer.setPixelRatio( window.devicePixelRatio )
  renderer.setSize( window.innerWidth, window.innerHeight )
  let canvas = document.getElementById('canvas')
  canvas.appendChild( renderer.domElement )

  controls = new OrbitControls( camera, renderer.domElement  )

  camera.position.z = 50

  window.addEventListener( 'resize', onWindowResize, false )

  animate()
}

var animate = function () {
  requestAnimationFrame( animate )
  controls.update()
  renderer.render( scene, camera )
}
  
function onWindowResize() {
  camera.aspect = window.innerWidth / window.innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize( window.innerWidth, window.innerHeight )
  animate()
}

function replaceCurrentMesh (threeMesh) {
  if (_threeMesh) {
    scene.remove(_threeMesh)
    _threeMesh.geometry.dispose()
  }
  _threeMesh = threeMesh
  scene.add(_threeMesh)
}

function meshToThreejs (mesh, material) {
  let loader = new THREE.BufferGeometryLoader()
  var geometry = loader.parse(mesh.toThreejsJSON(true))
  return new THREE.Mesh(geometry, material)
}

function zoomCameraToSelection( camera, controls, selection, fitOffset = 1.2 ) {
  
  const box = new THREE.Box3();
  
  for( const object of selection ) box.expandByObject( object );
  
  const size = box.getSize( new THREE.Vector3() );
  const center = box.getCenter( new THREE.Vector3() );
  
  const maxSize = Math.max( size.x, size.y, size.z );
  const fitHeightDistance = maxSize / ( 2 * Math.atan( Math.PI * camera.fov / 360 ) );
  const fitWidthDistance = fitHeightDistance / camera.aspect;
  const distance = fitOffset * Math.max( fitHeightDistance, fitWidthDistance );
  
  const direction = controls.target.clone()
    .sub( camera.position )
    .normalize()
    .multiplyScalar( distance );

  controls.maxDistance = distance * 10;
  controls.target.copy( center );
  
  camera.near = distance / 100;
  camera.far = distance * 100;
  camera.updateProjectionMatrix();

  camera.position.copy( controls.target ).sub(direction);
  
  controls.update();
  
}

        </script>
    </body>
</html>
